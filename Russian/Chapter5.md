# 5. Фронт-энд для разработки игр Klaytn Addition
 
## 5.1 Настройки


Теперь, когда вы создали контракт, который будет использоваться для BApp в предыдущих классах, давайте сделаем предварительную разработку.
Сначала давайте приступим к базовой настройке.
В этом уроке я скачаю node.js, npm, инфраструктуру Truffle и код Visual Studio.
Node.js - это серверная JavaScript-платформа, которая нам реально нужна для нашего BApp.
Npm устанавливается вместе с node.js, который необходим для загрузки инструментов и библиотек во время разработки.
Платформа Truffle, которую мы будем устанавливать, также должна быть загружена через npm.
Если у вас уже установлены node.js и npm, проверьте версию и пропустите этот раздел, если node.js версии 8 или выше, а npm версии 5 или выше.


Пожалуйста, зайдите на https://nodejs.org и загрузите 10.15.3 LTS. Затем установите его.
Я уже сделал это, и поэтому я пропускаю этот шаг.
После установки мы проверим, правильно ли установлен node.js в PowerShell.
Введите Node-v и проверьте версию. а также проверьте Npm. Npm -v, да, он установлен правильно.


Наконец, я установлю Truffle.
Truffle - это фреймворк, который помогает вам легко развивать BApp.
Truffle позволяет вам компилировать, тестировать и развертывать смарт контракты.
Это очень популярный фреймворк.
Версия Truffle недавно была обновлена до 5.
Однако, поскольку Klaytn был разработан для версии 4, я буду использовать версию Truffle 4.
Если у вас уже установлена версия 4 или менее или 5, сначала необходимо удалить ее.
Удалите ее, введя `npm uninstall -g truffle` в PowerShell.
Теперь вставьте «npm install -g truffle@4.1.15», после установки вы получите версию 4.


Если вы все загрузили, проверьте версию с помощью команды версии Truffle.
Это версия 4.1.15, а компилятор solidity  - версия 0.4.25.
solidity  - это язык программирования, с помощью которого вы можете писать умные контракты. Наконец, давайте загрузим лучший редактор кода,  Visual Studio. Зайдите на https://code.visualstudio.com/ для загрузки под Windows.
Я скачал его заранее. Так что я тоже пропущу эту часть.
Если вы загрузили его, пожалуйста, установите и запустите.
Код Visual Studio поддерживает кроссплатформенность, поэтому работает на Linux, Windows, Mac и включает ряд полезных функций, таких как поддержка отладки, управление git, подсветка синтаксиса и многое другое.




Теперь нажмите на вкладку расширения, чтобы установить расширение для поддержки языка solidity. Пожалуйста, введите «solidity» и выберите тот, что сверху.
Нажмите Установить. Это расширение обеспечивает цветовую подсветку для каждого элемента грамматики solidity и позволяет вам компилировать.
Установка завершена. Я закончил сеанс настройки, который необходим для фронт-энд разработки.
 
 
## 5.2 Скачать шаблон
 
 
Давайте скачаем boiler plate, базовый шаблон для разработки.
Klaytn  говорит, что BApp может быть разработан в рамках Truffle.
 В Truffle есть несколько мест, где вы можете скачать стандартные шаблоны для вашей разработки BApp.
 Это называется Truffle Box.
«Https://truffleframework.com/boxes»
Если Вы зашли по ссылке, Вы можете увидеть шаблоны.
 Например, если вы хотите разработать BApp с использованием Angular или React, вы можете загрузить подходящий вам шаблон.
Однако загруженные здесь шаблоны специализируются на приложении Ethereum, поэтому вам необходимо загрузить их и стереть внутренние части.
 Затем Вы должны настроить шаблон для Klaytn.
Это не сложная часть, но я заранее скачал шаблон под названием webpack
и изменил его «Klaytn way», чтобы вписаться в нашу лекцию.
 Я загрузил его на Github, чтобы вы могли скачать его.
 Для справки, мы продолжим работу с нативным JavaScript и JQuery.
 Даже если вы новичок в этом, вы можете легко следовать за нами
 
Откройте PowerShell и выполните команду git clone в «https://github.com/kkagill/addition-game-starter.git» в том месте, куда вы хотите его скачать.
Я все это уже скачал.
Сделайте «Cd addition-game-starter», чтобы войти в патч. Теперь код. Давайте посмотрим на структуру, вставив «code».
Позвольте мне начать сверху вниз.
В папке «Contracts » хранятся файлы контрактов на solidity
У нас есть файл контракта «Addition Game», который мы создали, и у нас есть контракт под названием «migrations», который позволит вам запускать файлы сценариев в папке миграций ниже, когда вы развертываете свой смарт-контракт.
Это необходимый файл для развертывания контракта, поэтому вы никогда не должны его удалять.
 
Далее, файлы сценариев в папке `migrations` содержат логику, используемую в процессе развертывания.
Если вы видите этот файл, он импортирует файл контракта миграции и развертывает его содержимое на ноде Klaytn.
Внутри папки src я настроил структуру, которая состоит из внешнего интерфейса BApp. Файл index.html будет отвечать за первичное представление.
Я загрузил jquery и bootstrap для использования в BApp вместе с cdn и заранее добавил часть css ниже.
 
Файл Index.js похож на движок - он выполняет функции.
Мы уже определили имена функций, которые мы напишем в будущем.
Переменная внизу - это переменная конфигурации, которая показывает счетчик при загрузке. Это не самая важная часть, поэтому я добавил ее заранее.
В package.json вы добавляете необходимые зависимости через npm.
Важно то, что вы загрузите файл библиотеки, который позволит вам общаться с caver-js, блокчейном Klaytn.
Это похоже на web3 js Ethereum.
Truffle.js отвечает за настройку среды.
Через Truffle вы будете определять, в каких сетях будут внедряться интеллектуальные контракты.
Я расскажу об этом в следующей лекции.
Webpack оптимизирует файлы и обнаруживает изменения в коде и отображает изменения в браузере, не обновляя страницы.
До сих пор я загружал и объяснял стартовый шаблон для создания приложения игры Klaytn BApp.
 



## 5.3 Развертывание смартконтракта на Baobab 1
 
Теперь давайте развернем смартконтракт AdditionGame, который мы формирем в тестовой сети Baobab. Прежде чем мы начнем, мы запустим команду npm install в терминале и установим необходимые зависимости для BApp.
Если вы не видите терминал ниже, выберите новый терминал на вкладке Терминал.
Теперь запустите команду установки npm.
Это займет некоторое время. По завершении создается папка с именем «node_modules» и установка завершается.
 
 
 
Сначала давайте создадим новый файл в папке миграций.
Щелкните правой кнопкой мыши папку «Миграция» и выберите «Новый файл». Установите имя  «2_deploy_contracts.js», и мы добавим логику для развертывания контракта AdditionGame на ноде.
 
Перейдите к файлу `Initial migrations`, скопируйте и вставьте все коды.
Пожалуйста, измените его на «importing the AdditionGame contract».
Замените часть, которая будет развернута, на `AdditionGame`. Пока основная логика для развертывания закончена.
Тем не менее, я напишу определенный код в некоторые файлы в BApp для хранения информации, которую я получаю в процессе развертывания. Позже это может быть очень полезно для создания экземпляров контрактов с этой информацией.
deployer.deploy (AdditionGame)
 
Приложение развертывает контракт AdditionGame, и через `then` мы получаем  данные json.
И в них
 
if (AdditionGame._json) {
 
Если вы получили данные json игры Additions, вы сохраните их в файл через модуль файловой системы.
Чтобы сделать это, вы должны сначала импортировать его.
Добавьте `const fs = require ('fs')` сверху.
Хорошо, тогда я создам два файла. В этих файлах мы можем сохранить Abi и адрес контракта. Щелкните правой кнопкой мыши в любом месте фона и назовите новый файл «deployedABI».
Создайте еще один и назовите его «deployedAddress».
Теперь мы будем использовать файловую систему для хранения их в каждом файле.
Во-первых, давайте создадим код, который хранит информацию abi.
Abi  - это контент, который может взаимодействовать между блокчейном и контрактом.
  	fs.writeFile(
    	'deployedABI',
    	JSON.stringify(AdditionGame._json.abi),
 
В файловой системе есть функция writeFile. Определите, какой файл записать, и зафиксируйте информацию abi, которую мы получили от json, и передайте ее аргументу. Наконец, мы обработаем ошибку.
 
    	(err) => {
      	if (err) throw err
      	console.log("파일에 ABI 입력 성공");
    	})
Если есть ошибка, удалите ее. Если нет, запишите журнал на консоли. Это сохраняет информацию abi развернутого контракта в файле deployedABI как литерал. Для продолжения я сохраню адрес развернутого контракта в файл.
fs.writeFile(
  	'deployedAddress',
  	AdditionGame.address,
  	(err) => {
    	if (err) throw err
    	console.log("파일에 주소 입력 성공");
	})
Если вы уже выполнили все этапы,  мы можем сохранять необходимую информацию в каждом файле сразу после каждого его развертывания. Я продолжу настраивать среду в truffle.js и разверну ее в следующей лекции.
 
 
 
## 5.4 Развертывание смартконтракта на Baobab 2
 
 
Наконец, вам нужно установить настройки. Вы должны решить, какую сеть вы собираетесь развернуть.
Перейдите в файл Truffle.js. Теперь работаем с этого момента. Во-первых, я импортирую библиотеку с именем `connect-privkey-to-provider.`
const PrivateKeyConnector = require ('connect-privkey-to-provider')
 
также создаем константу, называемую идентификатором сети.
 
const NETWORK_ID = '1001'
 
1001 means Baobab's unique network ID.
const GASLIMIT = '20000000'
 
Это предел газа для развертывания. Всего семь нулей.
const URL = `https://api.baobab.klaytn.net:8651`
 
Для UR я назначил адрес, где в настоящий момент работает полная нода Klaytn, в тестнете baobab. Наконец, нам нужна константа для хранения секретного ключа, поэтому мы получим секретный ключ учетной записи, которую мы создали ранее через Klaytn Wallet. Я говорил вам, ребята,  сохранить ваш секретный ключ. Я копирую и вставляю свой, который я сохранил в блокноте.
const PRIVATE_KEY = ''
 
 
Теперь давайте использовать эти настройки в module.exports.
module.exports = {
  networks: { 
	klaytn: {
  	provider: new PrivateKeyConnector(PRIVATE_KEY, URL),
  	network_id: NETWORK_ID,
  	gas: GASLIMIT,
  	gasPrice: null,
	}
  },
}
 
 Позвольте мне объяснить это в первую очередь. Я сказал, что мы будем использовать «Klaytn» для сетей.
Теперь мы укажем четыре варианта. Сначала вы указываете провайдера, который предоставляет узел Klaytn. Создайте экземпляр PrivateKeyConnector и передайте два аргумента.
Первый - передать секретный ключ моей учетной записи, а второй - сетевой адрес, на котором работает полный узел.
Это позволит мне подключиться к тестовой сети баобаба, используя мой секретный ключ.
Присвойте идентификатор сети и газ, и, наконец, цена на газ будет установлена на нулевое значение. Сеть Baobab автоматически установит цену на газ, поэтому мы передаем нулевое значение.
Да, сейчас я настроил свою среду для развертывания смартконтрактов. Это довольно просто. Теперь давайте развернем их. В терминале запустите `truffle deploy -network klaytn`. Да, контракт успешно развернут. Вы можете увидеть фразу подтверждения, в консоли.
 
 
 
Теперь, если вы посмотрите на файл deployedABI, увидите, что информация abi сохраняется. Перейдите к развернутому адресу и обратите внимание, что адрес развернутого контракта сохраняется. Все работает хорошо. Наконец, при развертывании создается папка с именем build. Внутри него есть папка "contracts", а два файла json находятся в папке contracts. Они называются артефактами. Каждый файл артефакта содержит информацию ABI соответствующего контракта, а также всю информацию, связанную с контрактом. ABI - это аббревиатура двоичного интерфейса приложения; мы ранее сохранили развернутый файл ABI в нем. В abi мы видим функции и переменные, записанные в формате json, который мы используем для контракта AdditionGame.
 
Проще говоря, при развертывании этого контракта в блокчейне abi гарантирует вызов функций в контракте и гарантирует, что данные будут возвращены в ожидаемом формате. Именно здесь вы определяете, как вы можете взаимодействовать с контрактом. Если пройти вниз, там есть сетевой раздел. 1001 - уникальный идентификатор сети Klaytn. Этот контракт в настоящее время размещен по этому адресу в тестовой сети Baobab.
 
 
truffle deploy –compile-all –reset –network klaytn
 
 
Наконец, если вы хотите повторно развернуть контракт на узле Klaytn, вы можете использовать эту команду. Например, когда нам нужно изменить договор, нам нужно повторно развернуть его на ноде. `truffle deploy -compile-all -reset -network – Klaytn`
компилировать все, перекомпилировать все контракты. Сброс принудительно запускает файлы сценариев в папке «Миграции». Запустите его, чтобы заново развернуть контракт на узле. Да. Успешно завершено. Откройте файл deployedAddress, и вы увидите, что адрес изменился. Я развернул Контракт в сети Klaytn Baobab, используя truffles.
 
 
 
 
 
## 5.5 Пользовательский интерфейс подтверждения аккаунта
 
 
Начните с входа в свою учетную запись, созданную с помощью кошелька Baobab.
У нас было два способа проверить наши аккаунты.
  Во-первых, вы можете использовать комбинацию файлов и паролей хранилища ключей, а во-вторых, проверить с помощью закрытого ключа.
Мы реализуем это, проверяя комбинацию файлов хранилища ключей и паролей.
Сначала я напишу HTML-код.
Перейдите в Index.html и добавьте фрагмент в тег body.
  <div class="container">
    <div class="row">
  	<div class="col-md-8 col-md-offset-2">
    	<h1 class="text-center">클레이튼(Klaytn)</h1>
    	<h3 class="text-center">속전속결 덧셈 게임</h1>
    	<h3 class="text-center">
      	<code>3초안에 맞출 시 0.1 KLAY 지급 이벤트</code> 
      	<button type="button"
              	class="btn btn-info pull-right"
              	id="login"
              	data-toggle="modal"
              	data-target="#loginModal">
              	로그인
      	</button>
      	<button type="button"
              	class="btn btn-info pull-right"
              	id="logout"
    	          style="display: none;"
              	onclick="App.handleLogout()">
              	로그아웃
      	</button>
    	</h3>        
    	<hr />
  	</div>
	</div>
  </div> 
 
 
 
Пожалуйста, остановите это видео сейчас и напишите этот код.
Очень простая настройка.
Классы в div используют начальную загрузку, чтобы интерфейс выглядел красиво.
 Я пропущу описание начальной загрузки.
Прежде всего, я выложил пояснительные фразы в верхней части.
Ниже мы добавили кнопки входа и выхода.
Когда я нажимаю на кнопку входа, система запускает модальное окно.
Когда я нажимаю кнопку выхода из системы, выполняется функция handleLogout.
Обратите внимание, что я установил кнопку выхода, она не появляется в css.
Давайте запустим приложение, и проверим, работает ли написанный нами код.
Запустите команду npm run dev на терминале.
Запустите Chrome и перейдите по адресу localhost: 8081.
Да, это не так красиво, но выглядит хорошо.
Теперь давайте создадим модальное окно, которое будет появляться при нажатии кнопки входа. ‘Https://bootstrapdocs.com/v3.3.6/docs/javascript/#modals’ Если вы зайдете на сайт начальной загрузки, вы можете получить модальный код.
Скопируйте эту часть и вернитесь в HTML-файл.
Я вставлю это за пределы div.
Теперь давайте изменим содержимое этого фрагмента.
Сначала установите для идентификатора div значение loginModal.
section.
  <div class="modal fade" tabindex="-1" role="dialog" id="loginModal">
 
Вам должно понравиться когда modal открывался при нажатии кнопки входа.
Он соответствует модальному значению атрибута data-target верхней кнопки входа в систему.
Далее мы изменим размер modal на меньший.
 
  <div class="modal-dialog modal-sm">
 
 
Удалить все модальные заголовки раздела.
Также удалите контент внутри модального тела.
Теперь добавьте часть, в которую можно загрузить файл хранилища ключей, и часть, где можно ввести пароль.
<div class="form-group">
   <label for="keystore">Keystore</label>
   <input type="file" id="keystore" onchange="App.handleImport()">
</div>
 
Установите тип ввода как файл и сделайте функцию handleimport для вызова в событии onchange.
  А ниже добавьте часть для пароля (비밀번호). 
 
Скопируйте и вставьте сверху.
<div class="form-group">
  <label for="input-password">비밀번호</label>
  <input type="password" class="form-control" id="input-password" onchange="App.handlePassword()">
   <p class="help-block" id="message"></p>
</div>
 
 
Если значение записано в окне ввода пароля, вызовите функцию handlePassword.
  И я добавил часть, которая будет отображаться в виде сообщения, когда проверка прошла успешно или произошла ошибка.
Наконец, измените`close` на `닫기(close)` и измените `safe changes` на `submission.`
<button type="button" class="btn btn-default" data-dismiss="modal">닫기</button>
        	<button type="button" class="btn btn-primary" id="submit" onclick="App.handleLogin()">제출</button>
 
Добавьте атрибут id и разрешите вызывать функцию handleLogin при нажатии.
Да, сейчас я проверю, что завершенный код работает нормально в приложении.
Нажмите кнопку входа.
Что ж, теперь модал работает, и у вас есть возможность выбрать файл и ввести пароль.
Вот, я создал пользовательский интерфейс для проверки учетных записей.
 
 
## 5.6 Логика проверки аккаунта (проверка хранилища ключей)
 
 
 
Теперь, когда мы создали интерфейс, показанный выше, давайте реализуем логику его работы.
  В Index.js в константе есть различные функции, которые называются App.
И, наконец, когда вы спуститесь вниз, вы увидите, что при загрузке страницы запускается функция запуска, которая существует в константе приложения.
Поэтому мы реализуем функцию start, но перед этим нам нужно загрузить библиотеку caver.js для связи с блокчейном Klaytn и создать ее экземпляр, чтобы ее можно было использовать для BApp.
Импортируйте Caver из "caver-js";
 
Вверху импортируйте caver.js.
Процесс создает одну константу для настройки среды.
 
const config = {
  rpcURL: 'https://api.baobab.klaytn.net:8651'
}
 
 
В конфиге есть rpcURL.
Мы определили, к какому узлу Klaytn подключаться и использовать.
Я сказал, что это baobab тестнет.
Наконец, мы создадим константу, которая создает экземпляр rpcURL, передавая его конструктору Caver.
const cav = new Caver(config.rpcURL);
 
 
Работа над созданием завершена, и эта константа теперь доступна в приложении.
  Теперь вам нужно запустить функцию, но перед этим, в функции запуска, вы должны сначала убедиться, была ли учетная запись проверена в течение сеанса.
Тем не менее, я оставлю эту часть напопозже, потому что мы будем использовать сессию в более поздней лекции, так что пока оставьте функцию запуска пустой.
Давайте сначала реализуем функцию handleImport.
  Мы должны быть в состоянии нажать на кнопку входа и выбрать файл хранилища ключей после того, как появится модальное окно.
Однако этот файл должен быть проверен, является ли он действительным файлом хранилища ключей или нет.
Давайте сделаем это в функции handleimport.
Сначала мы создаем объект FileReader и помещаем его в константу.
const fileReader = new FileReader();
 
 
Используйте функцию readAsText, чтобы прочитать выбранный файл.
fileReader.readAsText(event.target.files[0]);
 
 
event.target.files, эта часть показывает файл, который мы выбрали.
Когда выполнение readAsText завершено, происходит событие onload FileReader.
fileReader.onload = (event) => {  	
  
}
 
Событие, полученное обратным вызовом, другими словами, содержимое файла, теперь можно использовать в этом блоке кода.
Содержимое этого файла будет проверено, является ли он действительным файлом хранилища ключей.
Сначала добавьте блок try catch.
 
  try {
   	
  } catch (event) {
   	
  }
 
 
Теперь мы проверим if-предложение, является ли содержимое файла допустимым или нет, другими словами, является ли это фактическим файлом хранилища ключей.
if (!this.checkValidKeystore(event.target.result)) {
 
}
 
 
Я передал содержимое файла, который мы читаем, функции checkValidKeystore в качестве аргумента.
  Теперь давайте украсим функцию checkValidKeystore.
Эта функция принимает хранилище ключей в качестве аргумента и получает файл.
И файл хранилища ключей, который я получил, является файлом json.
Я изменю его на объект Javascript, чтобы использовать свойства этого файла json в качестве переменных.
	const parsedKeystore = JSON.parse(keystore);
 
 
Я использовал функцию синтаксического анализа json для анализа содержимого файла хранилища ключей, преобразования его в объект и сохранения его в константе.
Что нам делать дальше?
Убедитесь, что свойства, необходимые для вашей конфигурации хранилища ключей, введены правильно.
Давайте посмотрим на файл хранилища ключей и посмотрим, что нам нужно.
Основными элементами конфигурации хранилища ключей являются версия, идентификатор, адрес и криптография.
Без этих четырех полей файл хранилища ключей не может быть файлом хранилища ключей.
Итак, я проверю это через код.
const isValidKeystore = parsedKeystore.version &&
  	parsedKeystore.id &&
  	parsedKeystore.address &&
  	parsedKeystore.crypto;
 
 
В финале, необходимо получить эту константу.
return isValidKeystore;
 
 
Я снова проверил, является ли файл, который я только что импортировал, действительным файлом хранилища ключей.
Если нет, то сообщение показывает, что оно недействительно и завершает функцию.
$('#message').text('유효하지 않은 keystore 파일입니다.');
return;
 
Если он прошел проверку, мы сохраним содержимое файла хранилища ключей в глобальной переменной.
Во-первых, нам нужно создать глобальную переменную. Создайте ее в функции запуска
 
auth: {
	accessType: 'keystore',
	keystore: '',
	password: ''
  },
 
 
В объекте Auth есть три поля.
  AccessType - это метод проверки, который имеет тип хранилища ключей и тип закрытого ключа.
Мы продолжаем с типом хранилища ключей.
Поле Keystore хранит все содержимое файла хранилища ключей.
  Наконец, password - это поле, содержащее пароль, который будет объединен с файлом хранилища ключей.
Если мы вернемся к функции и пройдем проверку,
this.auth.keystore = event.target.result;
 
 
отправьте все содержимое загруженного файла в поле хранилища ключей созданной нами переменной auth.
После этого отправьте сообщение о том, что процесс успешен.
$('#message').text('keystore 통과. 비밀번호를 입력하세요.');
 
Разрешите сразу ввести пароль в поле пароля.
 
document.querySelector('#input-password').focus();
 
Наконец, при чтении файла, если есть ошибка, отправьте сообщение об ошибке в блоке catch и завершите функцию.
$('#message').text('유효하지 않은 keystore 파일입니다.');
return;
 
 
Да, пока функция Handleimport реализована хорошо.
Давайте проверим ее сейчас. Выберите файл хранилища ключей.
Будет отображено сообщение о пропуске, и фокус будет перемещен в ту часть, где можно ввести пароль.
Чтобы проверить иной случай, давайте выберем любой случайный файл.
Хорошо, сообщение об ошибке генерируется.
Работает хорошо.
Теперь давайте создадим функцию, которая сохраняет пароль в глобальной переменной, когда мы вводим пароль.
Это будет очень просто.
Если вы переходите на html, функция handlepassword вызывается при вводе пароля.
Затем, в функции handlepassword,
this.auth.password = event.target.value;
 
Получите значение пароля через событие html onchange, а затем присвойте его полю пароля глобальной переменной auth.
  Это было очень просто.
Итак я сделал файл проверки файла хранилища ключей.
  В следующей лекции я создам секретный ключ и добавлю информацию о своей учетной записи в кошелек.
 
## 5.7 Проверка аккаунта (интеграция кошелька)
 

Мы закончили лекцию для получения файла хранилища ключей и ввода пароля,
Теперь мы проверим, была ли учетная запись успешно подтверждена, когда мы отправляем эту информацию на ноду baobab.
Перед этим я заменю http в rpcURL на https.
Посмотрите на Index.html.
Когда я нажимаю кнопку отправки, она вызывает функцию handlelogin.
Итак, давайте реализуем функцию.
Сначала убедитесь, что accesstype является хранилищем ключей.
if (this.auth.accessType === 'keystore') { 
}

Причина, по которой мы пишем оператор if, заключается в том, что при проверке учетной записи мы используем хранилище ключей или закрытый ключ.
Сейчас мы используем только хранилище ключей.
Однако я добавил эти операторы if, чтобы, когда вы хотите использовать закрытый ключ для проверки,
Вы можете использовать if и, пожалуйста, добавьте оператор `try catch` ниже.
 
 
try {       
} catch (e) 
}

Настало время, наконец, использовать Caver.
Я задам вам задачу.
Что мы можем иметь на комбинации файла хранилища ключей и пароля?
Если вы хорошо запоминаете, вы можете ответить сразу.
Да, вы можете получить свой закрытый ключ.
Этот секретный ключ позволяет вам создать экземпляр кошелька.
Поэтому первое, что вам нужно сделать, это получить свой секретный ключ через файл хранилища ключей и пароль.
const privateKey = cav.klay.accounts.decrypt(this.auth.keystore, this.auth.password).privateKey;

Вы можете использовать функцию расшифровки через компоненты учетных записей caver.
Вы можете это расшифровать.
Если вы расшифровали его, вы можете вернуть расшифрованный объект учетной записи, передав в качестве аргументов содержимое файла хранилища ключей и пароль.
В объекте есть различные компоненты, и среди них мы получаем закрытый ключ и сохраняем его в константе.
Если при расшифровке возникнет ошибка, будет отправлено сообщение.
$('#message').text('비밀번호가 일치하지 않습니다.');
$(‘#message’).text(‘password is not matched.’);
 
Если ошибки нет, он создаст экземпляр кошелька через ваш секретный ключ.
 
this.integrateWallet(privateKey);



Передайте закрытый ключ в функцию integratewallet.
Теперь перейдите к функции integratewallet.
Здесь мы добавляем код, который получает экземпляр кошелька с помощью privatekey.
 
const walletInstance = cav.klay.accounts.privateKeyToAccount(privateKey);
 

Этот кошелек содержит информацию о учетной записи.
Затем добавьте этот экземпляр в мой кошелек.
cav.klay.accounts.wallet.add(walletInstance)
 

Если вы добавите мою учетную запись в кошелек Caver,
Вы можете легко вызвать информацию о своей учетной записи через  Caver при создании транзакции в будущем.
Следующим шагом является сохранение экземпляра кошелька в хранилище сеанса.
SessionStorage будет хранить экземпляр кошелька в области хранения в веб-браузере до тех пор, пока вкладка не будет закрыта или веб-браузер не будет отключен.
sessionStorage.setItem('walletInstance', JSON.stringify(walletInstance))
 
 

SetItem получает значение ключа в виде пары.
Первый параметр является ключем, а второй параметр является значением.
Итак, мне нужно будет загрузить информацию о моей учетной записи в сеанс.
Когда вы вызываете walletInstance со значением ключа, значение, сохраненное в паре, загружается автоматически.
Причиной использования sessionStorage является сохранение учетной записи в системе.
Потому что информация моего аккаунта, хранящаяся в моем кошельке, исчезает, когда я захожу на другой сайт или страница обновляет эту информацию.
Тем не менее, если вы сохраните в хранилище сеанса,
информация о вашей учетной записи будет сохраняться, даже если вы на некоторое время посетите другой сайт, а затем вернетесь к нему или обновите страницу.
Поэтому я буду реализовывать сеанс экземпляра кошелька в функции start позже и держать его в системе.
Прямо сейчас мне нужно обновить интерфейс.
Теперь, когда мы завершили проверку аккаунта через integrateWallet, нам нужно соответствующим образом изменить интерфейс.
this.changeUI(walletInstance);  

Я отправляю экземпляр кошелька в функцию changeUI.
Так что же нам делать с функцией changeUI?
Закройте свой модал.
$('#loginModal').modal('hide');
 

Также, скройте кнопку входа.
$("#login").hide();
 
Кроме того, измените кнопку выхода, которую вы спрятали ранее.
 
$('#logout').show();

И поскольку вы вошли в систему, я хочу, чтобы адрес моей учетной записи был виден.
$('#address').append('<br>' + '<p>' + '내 계정 주소: ' + walletInstance.address + '</p>');   
 

Этот код говорит мне, что он показывает адрес учетной записи в HTML, где атрибут id является адресом.
Я пойду в index.html и добавлю один div.
  <div class="text-center" id="address"></div>    

Да, вы можете увидеть адрес моей учетной записи в этом месте.
Я сделаю это здесь.
Теперь давайте проверим.
Нажмите кнопку «Вход» и откройте файл хранилища ключей.
Если вы введете свой пароль и нажмете кнопку отправки, ваша учетная запись будет подтверждена и появится кнопка выхода из системы.
Ниже вы можете увидеть адрес учетной записи.
Наконец, давайте реализуем функцию выхода из системы.
Перейдите на Index.html.
Обратите внимание, что когда я нажимаю кнопку выхода из системы, я вызываю функцию handlelogout.
Перехожу туда.
Здесь мы будем вызывать функцию с именем removeWallet.
this.removeWallet();
 

С помощью этой функции мы очистим кошелек и сессионное хранилище.
Перейдите к функции removeWallet и добавьте этот код.
cav.klay.accounts.wallet.clear();
 
Это процесс удаления моего экземпляра кошелька: информация об учетной записи, которая была добавлена в кошелек.
Затем очистите сеанс.
 
sessionStorage.removeItem('walletInstance');

Когда вы удаляете его, просто введите значение ключа.
Как результат, он вызывает функцию сброса и завершается.
this.reset();
 

Эта функция сброса просто инициализирует глобальную переменную auth.
Можно перейти к функции сброса и инициализировать авторизацию.
this.auth = {
      keystore: '',
      password: ''
    };
 

Существует также accesstype в Auth.
Но вам не нужно удалять accesstype, потому что это все равно будет хранилище ключей.
Вместо этого, после того мы вошли в систему, значение будет введено в поля хранилища ключей и пароля.
Я хочу выйти и безопасно стереть все.
Вернитесь к функции handleLogout и вставьте код, который обновляет страницу, и завершите ее.
Причиной обновления является возврат в исходное состояние интерфейса.
location.reload();
 

Теперь давайте сделаем тест и закончим.
При нажатии кнопки «Выход» информация об учетной записи исчезнет, и вы вернетесь к экрану инициализации после обновления.
Теперь, когда вы завершили логику проверки аккаунта,
давайте закончим раздел, который поддерживает проверку аккаунта через хранилище сеансов в следующем уроке.
 
 
## 5.8 Сеанс аккаунта

Давайте посмотрим, что произойдет, когда мы войдем и обновим страницу.
Нажмите кнопку входа и выберите файл хранилища ключей.
В этом состоянии нажмите F5, с целью обновить страницу.
Все будет сброшено.
Было бы хорошо, если бы я продолжал входить в систему.
Как мне это сделать?
Если нам удалось войти в систему, мы сохранили информацию о хранилище учетной записи в хранилище сеанса.
Я буду использовать этот факт сейчас.
Первая функция, которая загружается при запуске BApp, - это функция запуска.
Здесь я получаю информацию об учетной записи, хранящуюся в хранилище сеансов.
Итак, давайте перейдем к функции запуска,
const walletFromSession = sessionStorage.getItem ('walletInstance');
 

Если вы используете getItem и передаете значение ключа, значение, сохраненное в паре, извлекается и сохраняется в константе.
Я сохранил свой экземпляр кошелька.
После этого убедитесь, что walletFromSession содержит значение.
if (walletFromSession) {
 
}
 

If there is a value, create a try catch.
try { 
     
} catch (e) {
 
  }
 

Затем добавьте информацию о своей учетной записи обратно в кошелек.
cav.klay.accounts.wallet.add(JSON.parse(walletFromSession));

Когда страница обновляется или повторно посещается, информация о существующей учетной записи, которая была добавлена в кошелек, стирается, поэтому я добавляю ее обратно через сеанс.
Обновите пользовательский интерфейс, чтобы показать, что вы вошли как следующий участник.
  this.changeUI(JSON.parse(walletFromSession));
 

Появится кнопка выхода и покажет адрес вашей учетной записи.
Наконец, если значение в sessionStorage не является допустимым экземпляром Wallet, оно переходит к оператору catch.
Затем удалите кошелек в хранилище сеансов.
sessionStorage.removeItem('walletInstance');
 
Готово.
Теперь давайте проверим.
Когда вы обновляетесь, страница продолжает входить в систему, не возвращаясь в состояние инициализации.
До сих пор мы реализовали часть ведения проверки аккаунта.
 
 
 
 
## 5.9 Перевод KLAY через контракт (депозит)
 
 
Теперь я отправлю KLAY на контракт, используя учетную запись оператора.
Сначала давайте создадим пользовательский интерфейс.
Вы можете создать его в строке класса div.
 
 
<br />     
 
    <div class="row text-center">
      <div class="col-md-2 col-md-offset-5">
        <div id="owner" style="display: none;">
          <hr />
          <label>컨트랙에 KLAY 보내기</label>
          <div class="input-group">             
            <input type="number" class="form-control" id="amount" />
            <span class="input-group-btn">
              <button type="button" class="btn btn-default" onclick="App.deposit()">송금</button>
            </span>
          </div>
        </div>
      </div>       
    </div>
 

Пожалуйста, посмотрите видео и добавьте эту часть.
Я объясню вкратце.
Я настроил часть пользовательского интерфейса для отправки денег на контракт, невидимый через CSS.
Мы настроили функцию запуска депозита, когда вводим сумму и нажимаем кнопку перевода.
Теперь перейдем к функции депозита и реализуем ее.
 
Я объясню, как реализовать это в первую очередь.
Перевод Klay на контракт возможен только с аккаунта владельца.
Это возможно только с аккаунта лица, которое развернуло Контракт.
Другими словами, только организатор этого события может отправить Klay.
Если мы используем учетную запись владельца, мы получим доступ к функции депозита в договоре и переведем KLAY.
Процесс очень прост.
Сначала мы создадим пример, чтобы получить доступ к развернутому нами контракту.
Когда вы создаете экземпляр контракта, вам нужна информация abi и адрес развернутого контракта.
Под константами в верхней части,
const agContract = new cav.klay.Contract(DEPLOYED_ABI, DEPLOYED_ADDRESS);

Здесь deployed_abi и deployed_address являются глобальными константами, которые могут использоваться в BApp.
После развертывания контракта мы сохраняем информацию в файле deployedabi и файле deployedaddreess.
Установите его в веб-пакете, чтобы мы могли прочитать эту информацию и использовать ее как глобальную константу.
Если вы перейдете в файл Webpack.config.js, там будет аннотированный раздел.
Сделайте это сейчас.
Во время компиляции в веб-пакетах запустите эту часть, чтобы установить глобальные константы, называемые развернутым адресом и развернутым abi.
 
Проще говоря, мы читаем файл развернутого адреса через файловую систему и присваиваем адрес контракта глобальной константе.
Таким же образом мы храним информацию abi в глобальных константах, которые находится в файле deployedabi.
Вернемся к файлу Index.js.
 
 

Итак, помните, что эти две abi и адресная информация, отправленные создателю экземпляра контракта, передаются через глобальные константы, сгенерированные веб-пакетом.
Теперь, когда мы создали пример четырех контрактов, мы продолжим с функцией депозита.
Мы должны кое-что проверить, прежде чем отправлять деньги.
Вы должны убедиться, что вы только что вошли в учетную запись владельца.
Поэтому я должен привести две части информации.
Во-первых, я получаю информацию об учетной записи, зарегистрированной в данный момент.
Во-вторых, я получу переменную состояния владельца, хранящуюся в контракте.
Сначала я получу информацию для входа в систему.
const walletInstance = this.getWallet();

Перейдите к функции getwallet и получите информацию об учетной записи, которая существует в текущем кошельке.
if (cav.klay.accounts.wallet.length) {
      return cav.klay.accounts.wallet[0];
    }

Wallet [0] - это первая учетная запись, добавленная в кошелек, в которую я вошел.
Вы уже завершили реализацию функции.
Далее, давайте назовем значение переменной состояния владельца в контракте.
Перейдите к функции callOwner
return await agContract.methods.owner().call();
 

Мы получим доступ к функции владельца через созданный нами привер контракта на приложение игры и вызовем значение.
Используйте ключевое слово await для асинхронного получения значений.
Поскольку мы сделали необходимые действия до того, как отправим деньги, мы продолжим выполнять функцию депозита.
if (walletInstance) {
 
    }
 

Если экземпляр Wallet существует через функцию getwallet,
то нужно сравнить текущий зарегистрированный адрес учетной записи с адресом учетной записи владельца, полученный из контракта.
if (await this.callOwner() !== walletInstance.address) return; 
 

Если мы сравним их, но значения будут другими, мы больше не продолжаем и завершаем функцию.
 If it is the same
else {
}
 

Получим значение для ввода HTML.
var amount = $('#amount').val();

Если входящее значение существует
if (amount) {
}
 
Отправьте значение в депозитную функцию, используя экземпляр контракта.
 
agContract.methods.deposit().send({
 
})

Сейчас мы отправляем объект транзакции как фактор отправки.
Нам нужно указать три вещи.
Сначала мы должны сказать, кто вызывает эту функцию.
from: walletInstance.address,
 
Я сказал, что мы будем вызывать эту функцию для текущего зарегистрированного аккаунта.
Обратите внимание, что адрес Walletinstance - это учетная запись, которая завершила проверку учетной записи, и она имеет право подписать транзакцию.
Так что я не могу поместить любой адрес в поле «from».
В качестве значения могут использоваться только адреса, которые были проверены в BApp.
И установите потребление газа в пределах 250000.
 
gas: '250000',
 

Поскольку функция депозита в договоре подлежит оплате, вы должны передать поле значения.
value:
 

Мы должны преобразовать число, полученное от ввода html, в peb, который является минимальной единицей KLAY, и передать его.
Преобразуйте его, используя утилиту библиотеки caver.
cav.utils.toPeb(amount, "KLAY")

Теперь вы можете отправлять деньги с помощью функции депозитного контракта.
Но я могу использовать информацию, которая может быть получена асинхронно, вместо завершения транзакции, например
.once('transactionHash', (txHash) => {
    console.log(`txHash: ${txHash}`);
})
 

Во-первых, я могу получить хеш транзакции, и я сделал это видимым на консоли.
Обратите внимание, что оболочка журнала консоли - это не одиночная кавычка, а кавычка слева от цифры 1.
Будьте осторожны.
Далее вы можете получить подтверждение.
.once('receipt', (receipt) => {
   console.log(`(#${receipt.blockNumber})`, receipt);          
})

Получение подтверждения означает, что транзакция была успешно добавлена в блок.
Таким образом, вы можете проверить подтверждение, и увидеть блок, в который была добавлена транзакция.
Если обработка транзакции не удалась, вы можете получить ошибку.
.once('error', (error) => {
   alert(error.message);
  }); 
 

Если есть ошибка, появится сообщение.
Я написал логику, чтобы проверить успех после отправки транзакции.
Наконец, если в html-вводе нет полученной суммы, добавьте оператор return, который завершает функцию.
return;
 

Я завершил этап, которая отправляет KLAY в функцию депозита контракта, и я изменю пользовательский интерфейс и протестирую его в следующем уроке.
 
 
## 5.10 Перевод KLAY по контракту (изменение и тестирование интерфейса)
 
 

Я постараюсь изменить пользовательский интерфейс и провести тестирование.
Когда мы отправили KLAY в функцию депозита в предыдущем курсе и получили подтверждение, транзакция прошла успешно.
Что я должен делать после того, как мне это удалось?
Было бы хорошо, если бы система могла показать мне сообщение с напоминанием.
   alert(amount + " KLAY를 컨트랙에 송금했습니다.");  
 

И я обновлю страницу, чтобы увидеть баланс договора.
   location.reload();     
.

Я сказал, что собираюсь сделать баланс контракта видимым.
Помните, что мы создали функцию, которая загружала бы баланс контракта, когда мы писали смартконтракт.
Мы назовем эту функцию getBalance, она поможет увидеть баланс контракта.
Сначала мы добавим div, который отображает баланс контракта в html.
Перейдите в Index.html и добавьте один div под адресом, который показывает адрес моей учетной записи.
  <div class="text-center" id="contractBalance"></div>

И тогда мы покажем вам баланс контракта здесь.
Теперь, когда представление готово, давайте создадим функцию, которая загружает баланс из серверной части.
Перейдите к функции callcountractbalance и добавьте код.
return await agContract.methods.getBalance().call();
 

Часть, которая обращается к функции getbalance через экземпляр контракта и загружает значение. Да, это было просто.
Откуда я вызываю эту функцию callcountractbalance?
Как мне это назвать?
Если транзакция успешно выполняется в функции депозита и получает подтверждение, она обновляет страницу с помощью location.reload ().
Какова первая функция, которая выполняется при обновлении страницы?
Функция запуска выполняется первой.
Затем мы вызываем функцию changeUI из функции start.
Мне нужно добавить код для загрузки баланса контракта из функции changeUI, которая немедленно меняет интерфейс.
$('#contractBalance').append('<p>' + '이벤트 잔액: ' + cav.utils.fromPeb(await this.callContractBalance(), "KLAY") + ' KLAY' + '</p>');     

Это немного долго.
Я объясню.
Мы добавим сообщение в часть, которая показывает баланс контракта в HTML.
Вызовите функцию callContractBalance, чтобы получить баланс.
Однако баланс загружается в минимальных единицах KLAY, peb.
Это затруднило бы понимание того, сколько осталось, потому что цифра слишком большая.
Так что утилита caver имеет функцию fromPeb.
Это функция, которая может конвертировать из peb в другую единицу.
Я указал второй параметр для преобразования в KLAY.
В результате он показывает сальдо контракта, преобразованное в KLAY в html.
 

Наконец, перевод KLAY в контракт должен быть установлен только для учетной записи владельца.
Вам нужно только дать разрешение организатору процесса.
Поэтому я изменю функцию, чтобы она моглаотображать пользовательский интерфейс, который можно передавать только при входе в систему с учетной записью владельца. Перейдем к функции changeUI
if (await this.callOwner() === walletInstance.address) {
      $("#owner").show(); 
    }     
 
Я установил, чтобы div владельца показывался только тогда, когда адрес учетной записи владельца и адрес зарегистрированной учетной записи совпадают.
В html владелец div по умолчанию установлен невидимым.
Итак, когда вы войдете в систему учетной записью владельца, вы увидите эту часть.
Теперь давайте попробуем протестировать.
Я переустановлю его один раз.
Во-первых, убедитесь, что секретный ключ вашей учетной записи правильно введен в truffle.js.
Я перенесу его из терминала.
‘truffle deploy -compile-all -reset -network klaytn’ Я повторно развернул его для людей, которые его не развернули.
Ваше развертывание окончено.
Давайте проверим это, запустив npm run dev. Нажмите F12, чтобы открыть окно консоли.
Нажмите кнопку Войти
Поскольку вы вошли в свою учетную запись владельца, вы можете увидеть часть, где вы можете отправить деньги.
Давайте  отправим деньги. Отправьте 1 KLAY.
 
 

Вы можете увидеть хэш транзакции и информацию о получении через журнал консоли, если ваша транзакция прошла успешно.
Уведомление работает.
Похоже, что время, необходимое для транзакции, составило менее 3 секунд.
За эти 3 секунды происходит четыре процесса от создания транзакции до создания блока и его распространения в сети после завершения транзакции.
По сравнению с другими блокчейн платформами скорость обработки очень высокая.
Нажмите на уведомление, страница обновится, и сначала будет вызвана функция запуска,
и обновленный баланс контракта, функцией changeUI.
Функция транзакции работает хорошо.
Я хотел бы, чтобы счетчик нагрузки показал, как работает транзакция, хорошо или нет.
Это не является обязательным требованием, но я рекомендую вам сделать это для хорошего пользовательского интерфейса.
Перейдите в Index.js и импортируйте spin.js.
import {Spinner} from 'spin.js';

Перейдите к функции showpinner и сделайте так, чтобы она возвращала экземпляр spinner.
var target = document.getElementById('spin');
    return new Spinner(opts).spin(target);

И вызовите эту функцию из функции депозита.
var spinner = this.showSpinner();
 
После получения подтвержения остановите spinner.
 
  spinner.stop();  

Наконец, добавьте div, чтобы отобразить счетчик в html. Сделайте это под тегом <br/>.
<div id="spin"></div>    
 

Теперь давайте попробуем протестировать.
Да. Когда spinner вращается, появляется подтвержение.
Передаточная функция работает хорошо, а интерфейс хорошо отражается.
Я показал перевод KLAY со счета владельца в контракт.

## 5.11 Генерация случайного числа

Теперь давайте попробуем сделать интересную часть задания.
Давайте создадим два случайных числа, которые будут использоваться для сложения.
Я буду улучшать HTML в первую очередь.
Пожалуйста, добавьте этот код прямо над div.
<div class="row text-center">
        <div id="game" style="display: none;">   
          <div class="yellow-box" id="start">       
            <a href="#" onclick="App.generateNumbers()">시작</a>
          </div>     
          <div class="yellow-box" id="question" style="display: none;">
            <span id="num1"></span> + <span id="num2"></span> = ?          
            <div class="input-group">
              <input type="number" class="form-control" id="answer" />
              <span class="input-group-btn">
                <button type="button" class="btn btn-default" onclick="App.submitAnswer()">제출</button>
              </span>
            </div>
          </div>     
        </div> 
      </div>
<br />
 

Я сделал это невидимым с помощью CSS.
И я сделаю это видимым после того, как войду.
Нажатие на кнопку запуска, она вызывает функцию generateNumbers.
Затем функция сгенерирует два числа: одно для num1 и одно для num2.
Они используются в приложении.
Есть поле ввода, чтобы написать ответ.
Наконец, есть кнопка для отправки ваших ответов.
Простой HTML. Сейчас
я настрою его так, чтобы эту часть могли видеть только пользователи, прошедшие проверку.
Перейдите к функции changeUI и добавьте ее ниже logout.show (), чтобы показать игровой div.
$('#game').show();
 

Теперь давайте проверим это в html.
Если вы вошли в систему, вы можете увидеть приятный интерфейс желтого цвета в середине.
Теперь я установлю числа, которые будут видны при нажатии на кнопку «Пуск».
Давайте создадим случайные числа в функции чисел.
var num1 = Math.random();
 

Сначала мы вызываем случайную функцию класса Math.
Случайная функция случайным образом генерирует число с десятичной точкой меньше 0 и 1.
Но если вы сделаете это, число будет слишком маленьким, поэтому я собираюсь его умножить.
var num1 = Math.random() * 50;
 

Это сгенерирует случайное число от 0 до 49.
Но задача не должна быть слишком простой, поэтому я добавлю 10 к сгенерированному значению, чтобы вы могли генерировать как минимум две цифры.
var num1 = (Math.random() * 50) + 10;
 

Наконец, мы используем функцию floor для отбрасывания десятичной точки.
var num1 = Math.floor((Math.random() * 50) + 10);
 
Если вы сделаете это, у вас будет десятичное число от 10 до 59.
Далее создайте еще одно.
 
var num2 = Math.floor((Math.random() * 50) + 10);
 
Теперь мы будем хранить значения двух чисел в хранилище сессии.
Я сохраню ответ.
 
sessionStorage.setItem('result', num1 + num2);    

Это позже даст правильный ответ, когда пользователь ответит, и попытается сравнить ответы, данные пользователем.
Теперь, когда мы создали числа, мы должны их использовать.
Когда я нажму на Start в html, я скрою это начало и покажу  div ниже. И в то же время я сделаю два числа, сгенерированных функцией, видимыми в полях num1 и num2.
Давайте вернемся к функции и осуществим то, что мы только что сказали.
$('#start').hide();
 

Сделайте начало невидимым.
$('#num1').text(num1);
$('#num2').text(num2);

Пусть система покажет сгенерированные числа в полях num1 и num2.
И пусть это покажет вопрос div.
$('#question').show(); 
	

Наконец, переместите фокус туда, где я пишу ответы, чтобы я мог ответить сразу.
document.querySelector('#answer').focus();

Я проверю это сейчас.
Когда вы нажимаете Пуск, ваши случайные числа генерируются и отображаются в формате HTML.
Вскоре фокус переместился туда, где я пишу ответ.
Это конец сегодняшнего урока, и я постараюсь создать таймер в следующем уроке.

## 5.12  Генерация таймера



Let's create a timer and set the timeout for the addition problem to 3 seconds.
 Go to Html and make a div that shows the timer. I'll make it right under the spin div.
<div class="row text-center">
        <p id="timer"></p>
      </div>   
 
Go to index.js and go to the showtimer function. Here we use the setInterval function to show the number to be counted down. We’ll make the problem disappear after 3 seconds and the screen revert back to the start click.
 

Make a variable to save for 3 seconds.
$('#timer').text(seconds);

Show number 3 directly to the html which is showing the timer. 
I use the setinterval function and set it at 1 second interval.
  var interval = setInterval(function() {  
  }, 1000);
 

Now I can run something in 1 second interval.
$('#timer').text(--seconds);  
 

Decrement the number one by one to make it appear in html. 
Now, the value of this seconds variable is 0, that is, reset it again when setinterval is 0 after 3 seconds.
if (seconds <= 0) {
}     
 
When Seconds becomes 0
 
$('#timer').text('');
 

Initialize the number showing part
     $('#answer').val('');
답적었던input도 초기화시키구요	

Also initialize the input that was answered.
$('#question').hide();
 
Set the div not showing the problem. And,
 
$('#start').show();          
 

Show the div again that you can click start. Finally,
  clearInterval(interval);
 

Use the clearInterval to stop the time running in setinterval. Yes, I have created the showtimer function. Now let's call this function in the generateNumbers function.
this.showTimer();
 
If you do this, as soon as you click Start, the timer will be created and count down will be started. Let's try testing.
Click on Start. A timer will be generated below and start the count down for 3 seconds. After 3 seconds, it is reset again.
So far, I have created a timer.
 
 
 
## 5.13 Submitting answers and receiving KLAY
 
This is the last class. If the user submits the answer and the answer is correct, let's implement the part that sends the KLAY to the user account from the contract. Go to the submitAnswer function. Load the value of correct answer which is stored in the session storage.
const result = sessionStorage.getItem('result');
 

And, store the answers that the user has made in the variables.
var answer = $('#answer').val();  
 

Now, do a comparison.
if (answer === result) { }
 

If the user has answered the correct answer, press the confirm button while opening the confirm message window and send the KLAY to the user.
if (confirm("대단하네요^^ 0.1 KLAY 받기")) { }
 

If the user clicked the OK button, make sure the balance in the contract is at least 0.1 KLAY before sending it.
if (await this.callContractBalance() >= 0.1) { }

If so, call the receiveKlay function.
this.receiveKlay();
 

If it does not exist, send a notification message.
else { alert("죄송합니다. 컨트랙의 KLAY가 다 소모되었습니다."); }    
 

Finally, if the user did not get the correct answer, Send a notification.
else { alert("땡! 초등학생도 하는데 ㅠㅠ"); }
 
 
 

Yes your submitanswer function is up to here. 
Let's test it once. 
This message is displayed when the answer is wrong. 
When this is done, a confirm message window will appear to receive the KLAY. 
When you click OK, you will call the receiveklay function to transfer the KLAY. 
I have not implemented it yet. 
Let's implement the function. 
It's our last function.
 
When the user answers the correct answer, they pay the transaction fee through their account and get the KLAY. 
We will convert 0.1 KLAY in our contract transfer function to peb and pass it as an argument. 
First, let's show you how to load using a spinner during transaction processing.
var spinner = this.showSpinner();

In addition, we need the verified account address required for the transaction, so, load the Wallet instance.
const walletInstance = this.getWallet();
 

If the value of the wallet instance does not exist, exit the function.
if (!walletInstance) return;  
 

If so, use the contract instance to access the transfer function in the contract .
agContract.methods.transfer().send({
})
 
The transfer function of the contract receives one argument. 
You need use the caver utility to convert the KLAY to peb and pass it. 
 
cav.utils.toPeb(“0.1”, "KLAY")
 
And you said you need to send a transaction object in the send parameter. 
You need to specify who calls this function and how much the gas limit is set.
 
from: walletInstance.address,
gas: '250000'
 
Pass the Wallet instance, your account-verified address, and let the gas consume within 250,000. 
Note that the value field is not required. 
I will not pass the value because the transfer function is not a payable type. 
If you do this, you have finished all the values which will be passed. 
Now, after the transaction is processed, you should check whether it succeeded or not. 
I could check whether it(deposit) succeeded or not through this .once. 
However, there’s another way. 
I can get a receipt by using promise.
 
.then(function (receipt) {
});     

Wait asynchronously and receive the receipt value.
if (receipt.status) { }

There is a field called status in the Receipt object. 
If this is true, it is successful. 
So, if you succeed, Stop spinner.
spinner.stop(); 
 

Also, show notification messages
alert("0.1 KLAY가 " + walletInstance.address + " 계정으로 지급되었습니다.");      
 

Also, let's create a link in html so that the processed transaction can be checked directly from the scope. 
I'm going to create a new div. 
I will make it under the timer div.
<div class="row text-center">
   <div id="transaction"></div>
</div>  

<br />
 

You'll see the link in this section. 
Go back to the function and clear the transaction div first.
    $('#transaction').html("");
 

I’m clearing the transaction div to show a new link each time a transaction is created. 
Next, I'll add a link.
    $('#transaction')
      .append(`<p><a href='https://baobab.klaytnscope.com/tx/${receipt.txHash}' 
                   target='_blank'>클레이튼 Scope에서 트랜젝션 확인</a></p>`);
 
 
In the receipt returned by the promise, 
pass the transactionhash field to the url parameter of the KlaytnScope site so that you can see the transaction information just processed. 
Lastly, show you the last updated contract balance in html.
 
return agContract.methods.getBalance().call()
  .then(function (balance) {
});        
 
Call the getBalance function of the contract to recall the remaining balance in the contract.
 
 $('#contractBalance').html("");          
 

Clears the existing show balance display and shows the updated balance immediately.
$('#contractBalance').append('<p>' + '이벤트 잔액: ' + cav.utils.fromPeb(balance, "KLAY") + ' KLAY' + '</p>');           
 
The whole process is complete so far. 
Now, let's try testing. 
This time, I try to log in with a different account, not the owner account. 
You can continue with the owner account. 
If you have created another account, you can try it out as well.
 
If you solve the problem and press the OK button, the receiveKlay function is called. 
The notification message is displayed and the transaction has been successfully completed. 
You can close the notification message and see that your event balance is reduced. 
The balance in the contract has been reduced as it moves to your account. 
And the link was created at the bottom. 
If you click the link, you can see the information about the track we just created on the scope. 
Click on your account address and you'll see that the balance is growing. 
So far, I have tried to solve the problem and transfer the KLAY in the contract to my account.
